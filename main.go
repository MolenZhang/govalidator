package main

import (
	"bytes"
	"flag"
	"fmt"
	"generator/common"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	gStructName = flag.String("type", "", "struct type name")
	gTagName    = flag.String("tag", "valid", "tag name")
	gPath       = flag.String("path", "./", "file path")
	gDebug      = flag.Bool("debug", false, "show generated data")
)

const (
	gSuffix = "_validator" + common.AutoGeneratedSuffix
	temp    = `
	package {{.PackageName}}
	import (
		"fmt"
		"github.com/asaskevich/govalidator"
	)
	{{$typeString := "string"}}
	{{$typeInt := "int"}}
	{{$tagRequired := "required"}}
	{{$tagStub := "-"}}

	func (stru *{{.StructName}}) Validate() error {				
		{{range $kType, $vType := $.ColumnsType}}
			
			{{if stringcontains $vType $typeString}}
				{{/* type string */}}				
				{{range $kTag, $vTags := $.ColumnsTag}}				
					{{if eq $kType $kTag}}	
						{{$tagLength := "length"}}
						{{$uuid := "uuid"}}	
						{{$email := "email"}}							
						{{range $i, $vTag := $vTags}}										
							{{if stringEqualFold $vTag $tagRequired}}
								{{/* tag required */}}
								if len(stru.{{$kTag}}) == 0 {
									return fmt.Errorf("the parameter '%s' should not be blank!", "{{$kTag}}")
								}
							{{else if stringcontains $vTag $tagLength}}
								{{/* tag length */}}
								{{$length := getMinMax $vTag $tagLength}}
								var minLen = {{$length.Min}}
								var maxLen = {{$length.Max}}
								if minLen > maxLen || !govalidator.StringLength(stru.{{$kTag}}, "{{$length.Min}}", "{{$length.Max}}") {
									return fmt.Errorf("the length of parameter '%s' should be between '{{$length.Min}}' and '{{$length.Max}}'!", "{{$kTag}}")
								}
							{{else if stringEqualFold $vTag $uuid}}
								{{/* tag uuid */}}
								if !govalidator.IsUUID(stru.{{$kTag}}) {
									return fmt.Errorf("the parameter '%s' format error!", "{{$kTag}}")
								}
							{{else if stringEqualFold $vTag $email}}
								{{/* tag email */}}
								if !govalidator.IsEmail(stru.{{$kTag}}) {
									return fmt.Errorf("the parameter '%s' format error!", "{{$kTag}}")
								}
							{{else if stringEqualFold $vTag $tagStub}}
								{{/* tag stub, no operate*/}}
								
							{{else}}
								if true {
									return fmt.Errorf("the tag '%s' and type '%s' don't match!", "{{$vTag}}", "{{$vType}}")
								}
							{{end}}
						{{end}}
					{{end}}
				{{end}}
			
			{{else if stringcontains $vType $typeInt}}
				{{/* type int */}}				
				{{range $kTag, $vTags := $.ColumnsTag}}				
					{{if eq $kType $kTag}}
						{{$tagRange := "range"}}
						{{range $i, $vTag := $vTags}}																																										
							{{if stringcontains $vTag $tagRange}}
								{{/* tag range */}}	
								{{$range := getMinMax $vTag $tagRange}}								
								var minRange = {{$range.Min}}
								var maxRange = {{$range.Max}}
								if minRange > maxRange || !govalidator.Range(stru.{{$kTag}}, "{{$range.Min}}", "{{$range.Max}}") {
									return fmt.Errorf("the range of parameter '%s' should be between '{{$range.Min}}' and '{{$range.Max}}'!", "{{$kTag}}")
								}
							{{else if stringEqualFold $vTag $tagStub}}
								{{/* tag stub, no operate*/}}
							{{else}}
								if true {
									return fmt.Errorf("the tag '%s' and type '%s' don't match!", "{{$vTag}}", "{{$vType}}")	
								}						
							{{end}}
						{{end}}
					{{end}}			
				{{end}}
			{{end}}
		{{end}}

		return nil
	}
	`
)

// TempData 表示生成template所需要的数据结构
type TempData struct {
	FileName    string
	PackageName string
	StructName  string
	ColumnsType map[string]string
	ColumnsTag  map[string][]string
}

func main() {
	log.SetFlags(log.Lshortfile | log.Ltime)
	flag.Parse()
	if len(*gStructName) == 0 {
		flag.Usage()
		log.Fatal("struct type must be set")
	}

	common.WalkPathWithGoExt(*gPath, handleFile)
}

func handleFile(filename string) error {
	var tempData TempData
	tempData.ColumnsType = make(map[string]string)
	tempData.ColumnsTag = make(map[string][]string)

	pkg, err := common.GetPackageFromFile(filename)
	if err != nil {
		panic(err)
	}

	if len(pkg.Structs) == 0 {
		return nil
	}

	var target *common.Struct
	for _, sct := range pkg.Structs {
		if sct.Name == *gStructName {
			target = sct
			break
		}
	}
	if target == nil {
		fmt.Printf("target is null\n")
		return nil
	}

	if len(target.Columns) == 0 {
		panic(fmt.Sprintf("There is no fields in struct %s", target.Name))
	}

	tempData.StructName = target.Name
	tempData.PackageName = pkg.Name
	tempData.FileName = filename

	for _, field := range target.Columns {
		name := field.Name
		tempData.ColumnsType[name] = field.Type

		if len(*gTagName) != 0 {
			if len(field.Tag) == 0 {
				continue
			}

			tag := handleTags(field.Tag)
			if len(tag) == 0 {
				continue
			}

			tempData.ColumnsTag[name] = strings.Split(tag, ",")
		}
	}

	if *gDebug {
		//spew.Dump(tempData)
		tempData.writeTo(os.Stdout)
	}

	return tempData.WriteToFile()
}

func handleTags(tags string) string {
	re := regexp.MustCompile(fmt.Sprintf(`%s:"(.*?)"`, *gTagName))
	matchs := re.FindStringSubmatch(tags)
	if len(matchs) >= 1 {
		return matchs[1]
	}
	return ""
}

func (d *TempData) handleFilename() {
	absPath, _ := filepath.Abs(d.FileName)
	basePath := filepath.Dir(absPath)
	d.FileName = basePath + "/" + strings.ToLower(d.StructName) + gSuffix
	fmt.Println(d.FileName)
}

func getMinMax(str, tag string) map[string]int {
	var min int
	var max int

	out := make(map[string]int)
	fmt.Sscanf(str, tag+"(%d|%d)", &min, &max)

	out["Min"] = min
	out["Max"] = max

	return out
}

func (d *TempData) writeTo(w io.Writer) error {
	funcMap := template.FuncMap{
		"lower":           strings.ToLower,
		"stringcontains":  strings.Contains,
		"getMinMax":       getMinMax,
		"stringEqualFold": strings.EqualFold,
	}
	return template.Must(template.New("temp").Funcs(funcMap).Parse(temp)).Execute(w, d)
}

// WriteToFile 将生成好的模块文件写到本地
func (d *TempData) WriteToFile() error {
	d.handleFilename()
	file, err := os.Create(d.FileName)
	if err != nil {
		return err
	}
	defer file.Close()
	var buf bytes.Buffer
	_ = d.writeTo(&buf)
	formatted, _ := format.Source(buf.Bytes())
	file.Write(formatted)
	return err
}
